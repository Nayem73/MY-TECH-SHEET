# SSLCOMMERZ

According to the SSLCOMMERZ github instruction, I ..

1. created PaymentInfo class to map all the payment related infos Including amount, trnxid, bank etc to our database table.

2. created PaymentController class. From this class, I call the initTrnxnRequest mehtod of TransactionInitiator class and pass the UserInfo and SubscriptionAmountService

3. In this TransactionInitiator class, I had to put my store_id and store_pass that I had to create from the sslcommerz website.

4. This TransactionInitiator class then calls the constructRequestParameters method of ParameterBuilder class to build a key value map of the information provided. All the customer information including the payment type, method, amount, a unique transaction id is created here. We create a new instance of PaymentInfo entity to save these record(the current transaction) to database, we will validate this transaction later. We also save these information to a map and After saving these information to a map, this method returns the map back to the TransactionInitiator class.

5. The ParameterBuilder class then calls the initiateTransaction method of the SSLCOMMERZ class and it returns me the paymentURL and I return this url back to the PaymentController class.

6. Now we need to validate if our payment is successful or not. After going through that link and completing the payment, the payemnt gateway will send back a response with all the information inside a key-value map. To recieive it, I created a successPage method inside the PaymentController class and it receives the response map that contains the payment information generated by sslcommerz. It then calls the receiveSuccessResponse method of TransactionResponseValidator class and passes the map that we received from sslcommerz.

# ACID

ACID is an acronym that stands for Atomicity, Consistency, Isolation, and Durability. These are a set of properties that guarantee that database transactions are processed reliably.

### Example of a database transaction:

Sure, let’s consider a banking system. Suppose you want to transfer money from your savings account to your checking account.

Here’s how it might look as a transaction:

1. **Step 1**: The system checks if your savings account has enough money for the transfer.
2. **Step 2**: If there’s enough money, the system subtracts the transfer amount from your savings account.
3. **Step 3**: The system adds the transfer amount to your checking account.

This entire operation, consisting of these three steps, is a single transaction. It’s important that all three steps complete successfully. If there’s a problem at any step (like if there’s not enough money in the savings account, or if there’s a system error while updating the checking account), the entire transaction should fail, and any changes made during the transaction (like the money subtracted from the savings account) should be undone. This is the concept of atomicity in ACID.

This is a simple example, but real-world database transactions can be much more complex, involving multiple operations on multiple tables or databases. But the basic idea is the same: a transaction is a group of operations that are performed as a single unit of work.

### Example of a simplified database transaction:

A database transaction is like a shopping trip to the supermarket. Let’s say you want to make a sandwich, so you need to buy bread, cheese, and ham.

In database terms, buying each item can be seen as an operation. The whole shopping trip, which includes all three operations, is a transaction.

So, if everything goes well, you’ll end up with all the items you need for your sandwich (the transaction is successful). But if the supermarket is out of ham, you might decide not to buy anything at all (the transaction is unsuccessful, and you roll back the operations).

In a database, a transaction might involve reading from and writing to multiple tables. Just like the shopping trip, either all the operations are successful, or none of them are. This ensures the database stays consistent and accurate.

1. **Atomicity**: This property ensures that a transaction is treated as a single, indivisible unit of work, which either completes entirely or not at all. If any part of the transaction fails, the entire transaction fails and the database is left unchanged.
2. **Consistency**: This means that the database must always follow its own rules. If a transaction would break these rules, it’s not allowed to happen. For example, if a rule says that an account balance can’t be negative, a transaction that would make it negative is not allowed.
3. **Isolation**: This property ensures that concurrent execution of transactions leaves the database in the same state as if the transactions were executed sequentially. In other words, the execution of one transaction is isolated from others.
-  Imagine two transactions happening at the same time. Isolation means that each one is done as if the other one isn’t happening. They don’t interfere with each other. For example, if two people are buying the last ticket at the same time, isolation ensures that only one of them can buy it.
4. **Durability**: This property ensures that once a transaction has been committed, it will remain committed even in the case of a system failure. This is typically achieved by storing transaction logs in non-volatile storage.
- This means that once a transaction is done, it’s done for good and can’t be undone, even if something like a power outage happens right after. For example, once the money is transferred to another account, it stays there even if the bank’s computers crash right after.

----

----

Sure, let’s break down the ACID properties using the bank transaction example:

1. **Atomicity**: This means that all steps of the transaction happen completely or not at all. In our example, if any step of the money transfer fails (like if there’s not enough money in the savings account, or if there’s a system error while updating the checking account), the entire transaction should fail. No money should be subtracted from the savings account unless it can be added to the checking account.

2. **Consistency**: This ensures that the transaction brings the database from one valid state to another, maintaining the integrity of the data. In our example, consistency ensures that the total amount of money in the savings and checking accounts remains the same before and after the transaction.

3. **Isolation**: This means that multiple transactions happening at the same time won’t affect each other. For example, even if two people are trying to withdraw money from the same account at the same time, each transaction would be processed separately, ensuring that each sees a “snapshot” of the account balance that’s unaffected by the other transaction.

4. **Durability**: This ensures that once a transaction is completed, it will remain so, even in the event of a power loss, crash, or other error. In our example, once the money transfer is completed, the changes to the savings and checking accounts will be saved and will persist even if the system crashes immediately after.

So, in simple terms, ACID ensures that each transaction is processed completely and correctly, even when multiple transactions are happening at the same time, and that once a transaction is done, it’s permanent.

----

---

In SQL, DDL, DML, DQL, and DCL are acronyms that represent different types of operations you can perform on a database:

1. **DDL (Data Definition Language)**: These are commands that define the structure of a database, like creating, altering, or deleting tables. [Examples are `CREATE`, `ALTER`, and `DROP`](https://learnsql.com/blog/what-is-dql-ddl-dml-in-sql/)[1](https://learnsql.com/blog/what-is-dql-ddl-dml-in-sql/)[2](https://www.geeksforgeeks.org/sql-ddl-dql-dml-dcl-tcl-commands/).

2. **DML (Data Manipulation Language)**: These are commands that manipulate the data in a database, like inserting, updating, or deleting data. [Examples are `INSERT`, `UPDATE`, and `DELETE`](https://learnsql.com/blog/what-is-dql-ddl-dml-in-sql/)[1](https://learnsql.com/blog/what-is-dql-ddl-dml-in-sql/)[2](https://www.geeksforgeeks.org/sql-ddl-dql-dml-dcl-tcl-commands/).

3. **DQL (Data Query Language)**: This is used to query data from a database. [The primary example is the `SELECT` command, which retrieves data](https://learnsql.com/blog/what-is-dql-ddl-dml-in-sql/)[1](https://learnsql.com/blog/what-is-dql-ddl-dml-in-sql/)[3](https://database.guide/what-is-dql/).

4. **DCL (Data Control Language)**: These are commands that control access to the database, like granting or revoking permissions. [Examples are `GRANT`, `REVOKE`, and `DENY`](https://learnsql.com/blog/what-is-dql-ddl-dml-in-sql/)[1](https://learnsql.com/blog/what-is-dql-ddl-dml-in-sql/)[2](https://www.geeksforgeeks.org/sql-ddl-dql-dml-dcl-tcl-commands/).

Each of these groups of commands allows you to interact with a database in different ways, and they’re all important parts of SQL.

# ForwardController (AI)

I used ResponseEntity extensively to return a response, because it can include http status code, http headers and http body < these 3 at the same time.

so when receiving the response from the frontend, i used responseentity to hold  MULTIPART_FORM_DATA as header type and the name of crop and the image as body . Then performed a HTTP post method to the fast api server of AI and received the response by a responseentity.
